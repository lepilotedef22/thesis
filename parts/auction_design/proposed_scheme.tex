\section{Proposed Scheme}
	Our proposed construction builds upon a \gls{dvrs} introduced by Saraswat and Pandey in \cite{saraswat2014leak}. The resulting scheme provides \textit{correctness}, \textit{unforgeability}, \textit{unpretendability} and \textit{bidder anonymity}. In this context, the auctioneer is the designated verifier trusted to open the bids. However, a collusion between malicious bidders and the auctioneer does not affect the outcome.

	There are three separate time frames for bid submission $[0,T_1]$, bid opening $[T_1,T_2]$ and winner declaration $[T_2,T_3]$. During the first time interval $[0,T_1]$, the bidders submit ring signed commitments of their bid and of their identity to the blockchain. During the second time interval $[T_1,T_2]$, the bidders reveal their bid by encrypting them using the public key of the auctioneer and sending them on chain. In the last interval $[T_2,T_3]$, the winning bidder reveals his identity to the auctioneer. In order to successfully realize our construction, we rely on the assumptions that the auctioneer is minimally trusted and assumed not to disclose the bidder's inputs; and that we assume the existence of a blockchain providing \textit{anonymity} and \textit{confidentiality} of the transactions on top of which our scheme can be implemented as a smart contract. This last assumption, despite the fact that it reduces the generality of the scheme, is not as strong as one might think. Indeed, the requested features can already be achieved, either by default in platforms such as Monero or Zcash \cite{sasson2014zerocash}, or in open blockchains such as Ethereum, by the addition of cryptographic protocols such as Zether \cite{bunz2019zether}, or stealth addressing. If our protocol is implemented on a platform with a built-in cryptocurrency, its security can be further improved by requiring the parties to deposit a given amount of cryptocurrency to the smart contract. The deposits get refunded to honest participants after the auction is concluded as an economic incentive.
	
\subsection{Our Generic Construction}

	Our construction is based on four algorithms. The first one, represented in Algorithm \ref{alg:gen}, is the key generation algorithm, $\keygen$, which generates the keys and the rings.  It can be used by the bidders and the auctioneer. The same keys are used for signature and encryption.

	\begin{algorithm}
	  \DontPrintSemicolon%
	  \SetKwProg{Fn}{Function}{:}{}%
	  \SetKwFunction{gen}{KeyGen}%
	  \SetKwFunction{rgen}{RGen}%
	  \SetKwFunction{getAuctioneer}{getAuctioneerIndex}%
	  \Fn{\gen{$1^k$}}{%
	    $(\pk,\sk_s,s)\gets$ \rgen{$1^k$}\;%
	    $v\gets\getAuctioneer{\pk}$\;%
	    \Return $(\pk,\sk_s, s, v)$\;%
	  }%
	  \caption{Key generation algorithm.}%
	  \label{alg:gen}%
	\end{algorithm}

	The second one, shown in Algorithm \ref{alg:bid} is the bid submission algorithm. The bidders use it to compute the commitment $c$ to the bid value that they choose, as well as $\mysign=\sigma||c_1||c_2$, which is chain of commitments on encrypted ring signatures. This approach allows to link the values of the different tokens in such a way that they cannot be changed later during the auction protocol. This algorithm also outputs the bid opening token $\tau_1=C_1||d_1$ and the identity opening token $\tau_2=C_2||d_2$. Two different rings of parties are used in this algorithm. The first one is arbitrarily constructed by the bidder to maintain his anonymity. The second one is used to ensure that the auctioneer cannot convince anyone that the bidder actually generated a given bid, since she is also included in the ring. For the sake of generality, two different \gls{rs} schemes can be used, $\mathtt{RSig}$ and $\mathtt{R2Sig}$ in this case.

	\begin{algorithm}
	  \DontPrintSemicolon%
	  \SetKwProg{Fn}{Function}{:}{}%
	  \SetKwFunction{bid}{Bid}%
	  \SetKwFunction{commit}{Commit}%
	  \SetKwFunction{rsig}{RSig}%
	  \SetKwFunction{rtwosig}{R2Sig}%
	  \SetKwFunction{enc}{Enc}%
	  \Fn{\bid{$\pk,\sk_s,\pk_v,x$}}{%
	    $(c,d)\gets\commit{x}$\;%
	    $\sigma\gets$ \rsig{$\pk,\sk_s,c$}\;%
	    $\Sigma\gets$ \rsig{$\pk,\sk_s,c||\sigma$}\;%
	    $m_1 = c||\sigma||\Sigma||d$\;%
	    $C_1\gets$ \enc{$\pk_v,m_1$}\;%
	    $(c_1,d_1)\gets $ \commit{$C_1$}\;%
	    $\delta\gets$
	    \rtwosig{$[pk_s,\pk_v],\sk_s,c||\sigma||\Sigma$}\;%
	    $m_2 = c||\pk_s||\pk_v||\sigma||\Sigma||\delta$\;%
	    $C_2\gets$ \enc{$\pk_v,m_2$}\;%
	    $(c_2,d_2)\gets$ \commit{$C_2$}\;%
	    \Return $(c, \sigma||c_1||c_2, C_1||d_1, C_2||d_2)$\;%
	  }%
	  \caption{Bid submission algorithm.}%
	  \label{alg:bid}%
	\end{algorithm}

	Algorithm \ref{alg:bidop} shows the bid opening algorithm, $\bidOp$, which is used to verify that the bid is valid, and to open and store its value. The bid opening token $\tau_1$ generated by the bidder is required. If the signatures and the commitments are successfully verified, the auctioneer stores locally the bid $x$ and the corresponding opening value $d$.

	\begin{algorithm}
	  \DontPrintSemicolon%
	  \SetKwProg{Fn}{Function}{:}{}%
	  \SetKwFunction{bidop}{BidOp}%
	  \SetKwFunction{parse}{parse}%
	  \SetKwFunction{rver}{RVer}%
	  \SetKwFunction{open}{Open}%
	  \SetKwFunction{dec}{Dec}%
	  \SetKwFunction{store}{Store}%
	  \Fn{\bidop{$\pk,\sk_v,c,\mysign,\tau_1$}}{%
	    $b\gets0$\;%
	    $\sigma,c_1,c_2\gets$ \parse{$\mysign$}\;%
	    \If{\rver{$\pk,c,\sigma$}}{%
	      $C_1, d_1\gets$ \parse{$\tau_1$}\;%
	      \If{$C_1 =$ \open{$c_1,d_1$}}{%
	        $m_1\gets$ \dec{$\sk_v, C_1$}\;%
	        $\tilde{c}, \sigma, \Sigma, d\gets$ \parse{$m_1$}\;%
	        \If{$\tilde{c}=c$}{%
	          \If{\rver{$\pk,c||\sigma, \Sigma$}}{%
	            $x\gets$ \open{$c,d$}\;%
	            \store{$x$}\;%
	            \store{$d$}\;%
	            $b\gets1$\;%
	          }%
	        }%
	      }%
	    }%
	    \Return $b$\;%
	  }%
	  \caption{Bid opening algorithm.}%
	  \label{alg:bidop}%
	\end{algorithm}

	Finally, $\idOp$ the identity opening algorithm shown in Algorithm \ref{alg:idop} allows the auctioneer to check that the identity of the winning bidder is valid and to obtain his public key. The corresponding identity opening token $\tau_2$ is needed. The \gls{rs} is verified using the ring made of the public keys of the winning bidder and the auctioneer only. If the identity is successfully verified, the winning bidder's public key is stored locally by the auctioneer.

	\begin{algorithm}
	  \DontPrintSemicolon%
	  \SetKwProg{Fn}{Function}{:}{}%
	  \SetKwFunction{idop}{IdOp}%
	  \SetKwFunction{parse}{parse}%
	  \SetKwFunction{open}{Open}%
	  \SetKwFunction{dec}{Dec}%
	  \SetKwFunction{getWin}{getWinningCommitment}%
	  \SetKwFunction{rtwover}{R2Ver}%
	  \SetKwFunction{store}{Store}%
	  \Fn{\idop{$\sk_v,\mysign,\tau_2$}}{%
	    $b\gets0$\;%
	    $\sigma, c_1, c_2\gets$ \parse{$\mysign$}\;%
	    $C_2,d_2\gets$ \parse{$\tau_2$}\;%
	    \If{$C_2=$ \open{$c_2,d_2$}}{%
	      $m_2\gets$ \dec{$\sk_v, C_2$}\;
	      $c,\pk_s,\pk_v,\sigma,\Sigma,\delta\gets$ \parse{$m_2$}\;
	      \If{$c=$ \getWin{}}{%
	        \If{\rtwover{$[\pk_s,\pk_v],c||\sigma||\Sigma,\delta$}}{%
	          \store{$\pk_s$}\;%
	          $b\gets1$\;%
	        }%
	      }%
	    }%
	    \Return $b$\;%
	  }
	  \caption{Identity opening algorithm.}
	  \label{alg:idop}
	\end{algorithm}

\subsection{Anonymous Fair Auction Protocol}

	The protocol implementing our construction is presented in Algorithm \ref{alg:protocol}. The first step is concerned with the generation of the keys for the auctioneer and the bidders. Before time $T_1$, each bidder chooses a bid and executes $\mathtt{Bid}$, to get the 4-tuple $(c_i, \mysign_i, \tau_{i1}, \tau_{i2})$, sends $c_i$ and $\mysign_i$ to the blockchain and stores locally the opening tokens.
	
	\begin{algorithm}%
	  \DontPrintSemicolon%
	  \SetKwProg{Pr}{Protocol}{:}{}%
	  \SetKwFunction{anonymousauction}{anonymousAuction}%
	  \SetKwFunction{keygen}{KeyGen}%
	  \SetKwFunction{bid}{Bid}%
	  \SetKwFunction{choosebid}{selectBid}%
	  \SetKwFunction{bidop}{BidOp}%
	  \SetKwFunction{continue}{continue}%
	  \SetKwFunction{getbids}{getBids}%
	  \SetKwFunction{getdec}{getDecommitments}%
	  \SetKwFunction{auction}{verifiableAuction}%
	  \SetKwFunction{zkprove}{ZKProve}%
	  \SetKwFunction{sendbidder}{bidderSendToBlockchain}%
	  \SetKwFunction{getauctioneer}{auctioneerGetFromBlockchain}%
	  \SetKwFunction{sendauctioneer}{auctioneerSendToBlockchain}%
	  \SetKwFunction{idop}{IdOp}%
	  \Pr{\anonymousauction}{%
	    $(\pk^v, \sk_v, s, v)\gets$ \keygen{$1^k$} \tcp{Here, $s=v$.}%
	    \For{$i \in \{1\dots N\}$}{%
	      $(\pk^i, \sk_i, s, v)\gets$ \keygen{$1^k$} \tcp{Keys for
	        $i^{\text{th}}$ bidder.}%
	    }%
	    \For{$i \in \{1\dots N\}$}{%
	      $x_i\gets$ \choosebid{}\;%
	      $(c_i, \mysign_i, \tau_{i1}, \tau_{i2})\gets$ \bid{$\pk^i, \sk_i,
	        \pk^i_v, x_i$}\;%
	      \sendbidder{$c_i,\mysign_i$}\;%
	    }%
	    \For{$i \in \{1\dots N\}$}{%
	      \sendbidder{$\tau_{i1}$}\;%
	    }%
	    \For{$i \in \{1\dots N\}$}{%
	      $(c_i, \mysign_i, \tau_{i1})\gets$ \getauctioneer{}\;%
	      \If{\bidop{$\pk^i, \sk_v, c_i, \mysign_i, \tau_{i1}$}}{%
	        \continue\;%
	      }%
	    }%
	    $x\gets\getbids{}$, $d\gets\getdec{}$
	    $c\gets\getauctioneer{}$\;%
	    $(c_w, \text{success})\gets$ \auction{$x,c,d$}\;%
	    $\pi\gets$ \zkprove{$\CRS, (c,c_w), (x,d)$}\;%
	    \sendauctioneer{$c_w,\pi$}\;%
	    \For{$i \in \{1\dots N\}$}{%
	      \If{$c_i=c_w$}{%
	        \sendbidder{$\tau_{i2}$}\;%
	      }%
	    }%
	    $(\mysign_w,\tau_{w2})\gets$ \getauctioneer{}\;%
	    \If{\idop{$\sk_v,\mysign_w,\tau_{w2}$}}{%
	      \continue%
	    }%
	  }%
	  \caption{Anonymous Fair Auction protocol.}%
	  \label{alg:protocol}%
	\end{algorithm}%

	Between times $T_1$ and $T_2$, the bidders submit their respective bid opening token to the blockchain. The auctioneer fetches them, verifies the bids and stores their value. Then, the auctioneer computes the winning bid using the $\mathtt{verifiableAuction}$ algorithm and sends the commitment to the winning bid and the \gls{zkp} $\pi$ to the blockchain.  Finally, between times $T_2$ and $T_3$, the winning bidder submits his identity opening token. The auctioneer verifies the identity and stores the winner's public key.  During the whole auction process, the interactions between the auctioneer, the bidders and the smart contract can be listed as follows:
	
	\begin{itemize}
		\item $\mathtt{Tx_1}$: The auctioneer triggers the auction smart contract.
		\item $\mathtt{Tx_2}$: $c$ and $\mysign$ output by $\mathtt{Bid}$ are submitted by each bidder to the smart contract.
		\item $\mathtt{Tx_3}$: $\tau_1$ is submitted by each bidder to the smart contract.
		\item $\mathtt{Tx_4}$: The auctioneer declares the commitment to the winning bid and submits proof $\pi$.
		\item $\mathtt{Tx_5}$: $\tau_2$ is submitted by the winning bidder.
		\item $\mathtt{Tx_6}$: Auctioneer closes the auction.
	\end{itemize}

\subsection{Zero-Knowledge Proof}
	The \gls{zkp} system used in our scheme is shown in Algorithm \ref{verifiable_auction} and is a slightly modified version of the one proposed in \cite{galal2018succinctly}, where they designed their algorithm to handle a Vickrey auction, which implies that they have to return both the highest and the second highest bids. In our approach, we want to implement a first-price sealed-bid auction. Moreover, we do not want to disclose the value of the winning bid, hence the fact that our algorithm only returns its commitment. We also assume that all the bids are different. Regarding the generation of the $\CRS$, if this is done in a trusted, centralized way by the auctioneer, then a malicious auctioneer could compute fake \glspl{zkp}. Therefore, to ensure that the system is secure against a malicious auctioneer, the $\CRS$ setup should be realised by all the parties involved and by using Multi-Party Computation, as it is suggested in \cite{mpc_crs}.

\begin{algorithm}
  \DontPrintSemicolon%
  \SetKwProg{Fn}{Function}{:}{}%
  \SetKwFunction{ver}{verifiableAuction}%
  \Fn{\ver{x, c, d}}{%
    $highestBid \gets 0$\;%
    $c_w \gets \mathtt{null}$\;%
    success $\gets \mathsf{True}$\;%
    $i \gets 0$\;%
    \While(\tcp*[f]{$N$ is the constant number of bidders.}){$i<N$}{%
      \If{$x[i] \neq \Op(c[i], d[i])$}{%
        success $\gets \mathsf{False}$\;%
        \Return $c_w$, success\;%
      }%
      \If{$x[i] > \text{highestBid}$}{%
        $highestBid \gets x[i]$\;%
        $c_w \gets c[i]$\;%
      }%
      $i \gets i+1$\;%
    }%
    \Return $c_w$, success\;%
  }%
  \caption{Returns the commitment to the winning bid.}%
  \label{verifiable_auction}%
\end{algorithm}

	When the bidders have revealed their bids, the auctioneer executes Algorithm \ref{verifiable_auction} and determines $c_w$, which is the commitment to the highest bid stored on the blockchain, and is able to compute the proof $\pi$. In this situation, the publicly known statement, is the $(N+1)$-tuple $(c; c_w)$. The witness is the $2N$-tuple $(x, d)$, which is a made of the value of the bids as well as their opening value. The smart contract verifies the auction thanks to the proof $\pi$ and to $(c; c_w)$ by running $b \gets \ZKVer\left(\CRS, \pi, (c; c_w)\right)$. Since the \CRS, $\pi$ and $(c;c_x)$ are stored on the blockchain, one can leverage the auditability of inherent to this data structure to be convinced that the auction was executed correctly in a transparent, trustless configuration.

